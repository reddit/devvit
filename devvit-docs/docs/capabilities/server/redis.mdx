import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Redis

You can add a database to your app to store and retrieve data. The Redis plugin is designed to be fast, scalable, and secure. It supports a subset of the full Redis API, including:

- [Transactions](#transactions) for things like counting votes atomically in polls
- [String operations](#strings) for persisting information
- [Number operations](#numbers) for incrementing numbers
- [Sorted sets](#sorted-set) for creating leaderboards
- [Hashes](#hash) for managing a collection of key-value pairs
- [Bitfields](#bitfield) for efficient operation on sequences of bits

Each installation of an app is uniquely name-spaced, which means Redis data is siloed by subreddit. Keep in mind that there won’t be a single source of truth for all installations of your app, since each app installation can only access the data that it has stored in the Redis database.

## Limits and quotas

- Max commands per second: 40000
- Max request size: 5 MB
- Max storage: 500 MB
- [Pipelining](https://redis.io/docs/latest/develop/using-commands/pipelining/) is not supported
- [Sets](https://redis.io/docs/latest/commands/set/) - only sorted sets are supported
- No support for listing keys
- No support for lua scripts to execute custom logic on redis server

All limits are applied at a per-installation granularity.

## Examples

### Menu actions

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```js title="devvit.json"
  {
    "menuActions": [
      {
      "label": "Redis Test",
      "endpoint": "/internal/menu/redis-test",
      "forUserType": "moderator",
      "location": "subreddit"
      }
    ]
  }
  ```
  ```ts title="server/index.ts"
  // Assumes Express.js
  import { redis } from '@devvit/redis';
  router.post("/internal/menu/redis-test", async (_req, res: Response<UiResponse>) => {
    const key = 'hello';
    await redis.set(key, 'world');
    const value = await redis.get(key);
    console.log(`${key}: ${value}`);
  });
  ``` 
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts
  Devvit.addMenuItem({
    location: 'subreddit',
    label: 'Test Redis',
    onPress: async (event, { redis }) => {
      const key = 'hello';
      await redis.set(key, 'world');
      const value = await redis.get(key);
      console.log(`${key}: ${value}`);
    },
  });
  ```
  </TabItem>
</Tabs>


### Games

You can take a look at this [Game Template](https://github.com/reddit/devvit-template-phaser/) to see a basic implementation of Redis in a game built with Phaser.JS

## Supported Redis commands

:::note
Not all Redis features are supported. If you would like to request a specific Redis feature, please reach out to our team [via modmail](https://www.reddit.com/message/compose/?to=%2Fr%2FDevvit) or Discord.
:::

For all examples below, we assume that you already have obtained a Redis Client. Here's how to obtain a Redis Client for Devvit Web, Devvit Blocks and Mod Tools:

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```json title="devvit.json"
  {
    "permissions": {
      "redis": true
    }
  }
  ```
  ```ts title="server/index.ts"
  import { redis } from '@devvit/redis';
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts title="devvit.tsx"
  import { Devvit } from '@devvit/public-api';
  
  Devvit.configure({
    redis: true,
  });

  //Then, in any function that has a reference to Devvit.Context:
  const redis = context.redis;
  ```
  </TabItem>
</Tabs>


### Simple read/write

| **Command**                                | **Action**                                                            | **Limits** |
| ------------------------------------------ | --------------------------------------------------------------------- | ---------- |
| [get](https://redis.io/commands/get)       | Gets the value of key.                                                | None |
| [set](https://redis.io/commands/set)       | Sets key to hold a string value.                                      | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [exists](https://redis.io/commands/exists) | Returns number of given keys that exist.                              | None |
| [del](https://redis.io/commands/del)       | Removes the specified keys.                                           | None |
| [type](https://redis.io/commands/type)     | Returns the string representation of the type of value stored at key. | None |
| [rename](https://redis.io/commands/rename) | Renames a key.                                                        | None |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function simpleReadWriteExample() {
  // Set a key
  await redis.set('color', 'red');

  // Check if a key exists
  console.log('Key exists: ' + (await redis.exists('color')));

  // Get a key
  console.log('Color: ' + (await redis.get('color')));

  // Get the type of a key
  console.log('Type: ' + (await redis.type('color')));

  // Delete a key
  await redis.del('color');
}
```

```bash
Color: red
Type: string
```

</details>

### Batch read/write

| **Command**                            | **Action**                                      | **Limits** |
| -------------------------------------- | ----------------------------------------------- | ---------- |
| [mGet](https://redis.io/commands/mget) | Returns the values of all specified keys.       | None |
| [mSet](https://redis.io/commands/mset) | Sets the given keys to their respective values. | Subject to storage quota gating (writes may be blocked if quota exceeded) |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function batchReadWriteExample() {
  // Set multiple keys at once
  await redis.mSet({
    name: 'Devvit',
    occupation: 'Developer',
    yearsOfExperience: '9000',
  });

  // Get multiple keys
  console.log('Result: ' + (await redis.mGet(['name', 'occupation'])));
}
```

```bash
Result: Devvit,Developer
```

</details>

### Strings

| **Command**                                    | **Action**                                                                                                             | **Limits** |
| ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | ---------- |
| [getRange](https://redis.io/commands/getrange) | Returns the substring of the string value stored at key, determined by the offsets start and end (both are inclusive). | None |
| [setRange](https://redis.io/commands/setrange) | Overwrites part of the string stored at key, starting at the specified offset, for the entire length of value.         | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [strLen](https://redis.io/commands/strlen)     | Returns the length of the string value stored at key.                                                                  | None |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function stringsExample() {
  // First, set 'word' to 'tacocat'
  await redis.set('word', 'tacocat');

  // Use getRange() to get the letters in 'word' between index 0 to 3, inclusive
  console.log('Range from index 0 to 3: ' + (await redis.getRange('word', 0, 3)));

  // Use setRange() to insert 'blue' at index 0
  await redis.setRange('word', 0, 'blue');

  console.log('Word after using setRange(): ' + (await redis.get('word')));

  // Use strLen() to verify the word length
  console.log('Word length: ' + (await redis.strLen('word')));
}
```

```bash
Range from index 0 to 3: taco
Word after using setRange(): bluecat
Word length: 7
```

</details>

### Hash

Redis hashes can store up to ~ 4.2 billion key-value pairs. We recommend using hash for managing collections of key-value pairs whenever possible and iterating over it using a combination of `hscan`, `hkeys` and `hgetall`.

| **Command**                                   | **Action**                                                                        | **Limits** |
| --------------------------------------------- | --------------------------------------------------------------------------------- | ---------- |
| [hGet](https://redis.io/commands/hget)        | Returns the value associated with field in the hash stored at key.                | None |
| [hMGet](https://redis.io/commands/hmget)      | Returns the value of all specified field in the hash stored at multiple keys.     | May be disabled for your app (allowlisted feature) |
| [hSet](https://redis.io/commands/hset/)       | Sets the specified fields to their respective values in the hash stored at key.   | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [hSetNX](https://redis.io/commands/hsetnx/)   | Sets field in the hash stored at key to value, only if field does not yet exist.ƒ | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [hDel](https://redis.io/commands/hdel/)       | Removes the specified fields from the hash stored at key.                         | None |
| [hGetAll](https://redis.io/commands/hgetall/) | Returns a map of fields and their values stored in the hash.                      | None |
| [hKeys](https://redis.io/commands/hkeys/)     | Returns all field names in the hash stored at key.                                | None |
| [hScan](https://redis.io/commands/hscan/)     | Iterates fields of Hash types and their associated values.                        | No server-side cap; uses requested count |
| [hIncrBy](https://redis.io/commands/hincrby/) | Increments the score of member in the sorted set stored at key by value.          | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [hLen](https://redis.io/commands/hlen/)       | Returns the number of fields contained in the hash stored at key.                 | None |

<details>
  <summary>
    Code Examples
  </summary>

**Example 1**

```tsx
// Example using hGet(), hSet(), and hDel()
async function hashExample1() {
  // Set 'inventory' with multiple fields and values
  await redis.hSet('inventory', {
    sword: '1',
    potion: '4',
    shield: '2',
    stones: '8',
  });

  // Get the value of 'shield' from 'inventory'
  console.log('Shield count: ' + await redis.hGet('inventory', 'shield'));

  // Get the values of both of 'shield' and 'potion' from 'inventory'
  console.log('Shield and potion count: ' + await redis.hMGet('inventory', ['shield', 'potion']));

  // Delete some fields from 'inventory'
  console.log(
    'Number of fields deleted: ' +
      await redis.hDel('inventory', ['sword', 'shield', 'stones']);
  );
}
```

```bash
Shield count: 2
Shield and potion count: 2,4
Number of fields deleted: 3
```

---

**Example 2**

```tsx
// Example using hGetAll()
async function hashExample2() {
  // Set 'groceryList' to fields containing products with quantities
  await redis.hSet('groceryList', {
    eggs: '12',
    apples: '3',
    milk: '1',
  });

  // Get the groceryList record
  const record = await redis.hGetAll('groceryList');

  if (record != undefined) {
    console.log('Eggs: ' + record.eggs + ', Apples: ' + record.apples + ', Milk: ' + record.milk);
  }
}
```

```bash
Eggs: 12, Apples: 3, Milk: 1
```

---

**Example 3**

```tsx
// Example using hKeys()
async function hashExample3() {
  await redis.hSet('prices', {
    chair: '48',
    desk: '95',
    whiteboard: '23',
  });

  console.log('Keys: ' + (await redis.hKeys('prices')));
}
```

```bash
Keys: chair,desk,whiteboard
```

---

**Example 4**

```tsx
// Example using hScan()
async function hashExample4() {
  await redis.hSet('userInfo', {
    name: 'Bob',
    startDate: '01-05-20',
    totalAwards: '12',
  });

  // Scan and interate over all the fields within 'userInfo'
  const hScanResponse = await redis.hScan('userInfo', 0);

  hScanResponse.fieldValues.forEach((x) => {
    console.log("Field: '" + x.field + "', Value: '" + x.value + "'");
  });
}
```

```bash
Field: 'name', Value: 'Bob'
Field: 'totalAwards', Value: '12'
Field: 'startDate', Value: '01-05-20'
```

---

**Example 5**

```tsx
// Example using hIncrBy()
async function hashExample5() {
  // Set user123's karma to 100
  await redis.hSet('user123', { karma: '100' });

  // Increase user123's karma by 5
  console.log('Updated karma: ' + (await redis.hIncrBy('user123', 'karma', 5)));
}
```

```bash
Updated karma: 105
```

---

**Example 6**

```tsx
// Example using hLen()
async function hashExample6() {
  await redis.hSet('supplies', {
    paperclips: '25',
    pencils: '10',
    erasers: '5',
    pens: '7',
  });

  console.log('Number of fields: ' + (await redis.hLen('supplies')));
}
```

```bash
Number of fields: 4
```

</details>

### Numbers

| **Command**                                | **Action**                                        | **Limits** |
| ------------------------------------------ | ------------------------------------------------- | ---------- |
| [incrBy](https://redis.io/commands/incrby) | Increments the number stored at key by increment. | Subject to storage quota gating (writes may be blocked if quota exceeded) |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function numbersExample() {
  await redis.set('totalPoints', '53');

  console.log('Updated points: ' + (await redis.incrBy('totalPoints', 100)));
}
```

```bash
Updated points: 153
```

</details>

### Key expiration

| **Command**                                         | **Action**                                                        | **Limits** |
| --------------------------------------------------- | ----------------------------------------------------------------- | ---------- |
| [expire](https://redis.io/commands/expire/)         | Sets a timeout on key.                                            | None |
| [expireTime](https://redis.io/commands/expiretime/) | Returns the remaining seconds at which the given key will expire. | None |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function keyExpirationExample() {
  // Set a key 'product' with value 'milk'
  await redis.set('product', 'milk');

  // Get the current expireTime for the product
  console.log('Expire time: ' + (await redis.expireTime('product')));

  // Set the product to expire in 60 seconds
  await redis.expire('product', 60);

  // Get the updated expireTime for the product
  console.log('Updated expire time: ' + (await redis.expireTime('product')));
}
```

```bash
Expire time: 0
Updated expire time: 60
```

</details>

### [Transactions](https://redis.io/topics/transactions)

Redis transactions allow a group of commands to be executed in a single isolated step. For example, to implement voting action in a polls app, these three actions need to happen together:

- Store the selected option for the user.
- Increment the count for selected option.
- Add the user to voted user list.

The `watch` command provides an entrypoint for transactions. It returns a [TxClientLike](https://developers.reddit.com/docs/api/public-api/#-txclientlike) which can be used to call `multi`, `exec`, `discard`, `unwatch`, and all other Redis commands to be executed within a transaction.

You can sequence all of the above steps in a single transaction using `multi` and `exec` to ensure that either all of the steps happen together or none at all.

If an error occurs inside a transaction before `exec` is called, Redis discards the transaction automatically. See the Redis docs: [Errors inside a transaction](https://redis.io/docs/latest/develop/interact/transactions/#errors-inside-a-transaction) for more info.

| **Command**                                   | **Action**                                                                                                                                                                                                                                      | **Limits** |
| --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| [multi](https://redis.io/commands/multi/)     | Marks the start of a transaction block.                                                                                                                                                                                                         | Max concurrent transactions per installation: 20 (default) |
| [exec](https://redis.io/commands/exec/)       | Executes all previously queued commands in a transaction and restores the connection state to normal.                                                                                                                                           | Transaction execution timeout: 5 seconds |
| [discard](https://redis.io/commands/discard/) | Flushes all previously queued commands in a transaction and restores the connection state to normal.                                                                                                                                            | None |
| [watch](https://redis.io/commands/watch/)     | Marks the given keys to be watched for conditional execution of a transaction. `watch` returns a [TxClientLike](https://developers.reddit.com/docs/api/public-api/#-txclientlike) which should be used to call Redis commands in a transaction. | None |
| [unwatch](https://redis.io/commands/unwatch/) | Flushes all the previously watched keys for a transaction.                                                                                                                                                                                      | None |

<details>
  <summary>
    Code Examples
  </summary>

**Example 1**

```tsx
// Example using exec()
async function transactionsExample1() {
  await redis.mSet({ quantity: '5', karma: '32' });

  const txn = await redis.watch('quantity');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('karma', 10);
  await txn.set('name', 'Devvit');
  await txn.exec(); // Execute the commands in the transaction

  console.log(
    'Keys after completing transaction: ' +
      (await redis.mGet(['quantity', 'karma', 'name']))
  );
}
```

```bash
Keys after completing transaction: 5,42,Devvit
```

---

**Example 2**

```tsx
// Example using discard()
async function transactionsExample2() {
  await redis.set('price', '25');

  const txn = await redis.watch('price');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('price', 5);
  await txn.discard(); // Discard the commands in the transaction

  console.log('Price value: ' + (await redis.get('price'))); // 'price' should still be '25'
}
```

```bash
Price value: 25
```

---

**Example 3**

```tsx
// Example using unwatch()
async function transactionsExample3() {
  await redis.set('gold', '50');

  const txn = await redis.watch('gold');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('gold', 30);
  await txn.unwatch(); // Unwatch "gold"

  // Now that "gold" has been unwatched, we can increment its value
  // outside the transaction without canceling the transaction
  await redis.incrBy('gold', -20);

  await txn.exec(); // Execute the commands in the transaction

  console.log('Gold value: ' + (await redis.get('gold'))); // The value of 'gold' should be 50 + 30 - 20 = 60
}
```

```bash
Gold value: 60
```

</details>

### Sorted set

| **Command**                                                     | **Action**                                                                                                                                                                                                                                                      | **Limits** |
| --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| [zAdd](https://redis.io/commands/zadd/)                         | Adds all the specified members with the specified scores to the sorted set stored at key.                                                                                                                                                                       | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [zCard](https://redis.io/commands/zcard)                        | Returns the sorted set cardinality (number of elements) of the sorted set stored at key.                                                                                                                                                                        | None |
| [zRange](https://redis.io/commands/zrange/)                     | Returns the specified range of elements in the sorted set stored at key. <br /><br /> When using `by: 'lex'`, the start and stop inputs will be prepended with `[` by default, unless they already begin with `[`, `(` or are one of the special values `+` or `-`. | BYSCORE/BYLEX: LIMIT count capped to 1000 per call (server default). RANK: no server cap. Client default for by: 'score'/'lex' is count=1000 when no limit is provided. |
| [zRem](https://redis.io/commands/zrem/)                         | Removes the specified members from the sorted set stored at key.                                                                                                                                                                                                | None |
| [zScore](https://redis.io/commands/zscore/)                     | Returns the score of member in the sorted set at key.                                                                                                                                                                                                           | None |
| [zRank](https://redis.io/commands/zrank/)                       | Returns the rank of member in the sorted set stored at key.                                                                                                                                                                                                     | None |
| [zIncrBy](https://redis.io/commands/zincrby/)                   | Increments the score of member in the sorted set stored at key by value.                                                                                                                                                                                        | Subject to storage quota gating (writes may be blocked if quota exceeded) |
| [zScan](https://redis.io/commands/zscan/)                       | Iterates elements of sorted set types and their associated scores. Note that there is no guaranteed ordering of elements in the result.                                                                                                                         | No server-side cap; uses requested count |
| [zRemRangeByLex](https://redis.io/commands/zremrangebylex/)     | When all elements in a sorted set are inserted with the same score, this command removes the elements at key between the lexicographical range specified by min and max.                                                                                        | None |
| [zRemRangeByRank](https://redis.io/commands/zremrangebyrank/)   | Removes all elements in the sorted set stored at key with rank between start and stop.                                                                                                                                                                          | None |
| [zRemRangeByScore](https://redis.io/commands/zremrangebyscore/) | Removes all elements in the sorted set stored at key with a score between min and max (inclusive).                                                                                                                                                              | None |

<details>
  <summary>
    Code Examples
  </summary>

**Example 1**

```tsx
// Example using zRange() with by 'score'
async function sortedSetExample1() {
  await redis.zAdd(
    'leaderboard',
    { member: 'louis', score: 37 },
    { member: 'fernando', score: 10 },
    { member: 'caesar', score: 20 },
    { member: 'alexander', score: 25 }
  );

  // Cardinality should be '4' as there are 4 elements in the leaderboard set
  console.log('Cardinality: ' + (await redis.zCard('leaderboard')));

  // View elements with scores between 0 and 30 inclusive, sorted by score
  let scores = await redis.zRange('leaderboard', 0, 30, { by: 'score' });
  console.log('Scores: ' + JSON.stringify(scores));

  // Remove 'fernando' from the leaderboard
  await redis.zRem('leaderboard', ['fernando']);

  // View the elements sorted by score again. This time 'fernando' should not appear in the output
  scores = await redis.zRange('leaderboard', 0, 30, { by: 'score' });
  console.log('Updated scores: ' + JSON.stringify(scores));

  // View caesar's score
  console.log("Caesar's score: " + (await redis.zScore('leaderboard', 'caesar')));
}
```

```bash
Cardinality: 4
Scores: [{"score":10,"member":"fernando"},{"score":20,"member":"caesar"},{"score":25,"member":"alexander"}]
Updated scores: [{"score":20,"member":"caesar"},{"score":25,"member":"alexander"}]
Caesar's score: 20
```

---

**Example 2**

```tsx
// Example using zRange() with by 'lex'
async function sortedSetExample2() {
  await redis.zAdd(
    'checkpoints',
    { member: 'delta', score: 0 },
    { member: 'omega', score: 0 },
    { member: 'alpha', score: 0 },
    { member: 'charlie', score: 0 }
  );

  // View elements between the words 'alpha' and 'fox' inclusive, sorted lexicographically
  // Note that 'by: "lex"' only works if all elements have the same score
  const members = await redis.zRange('checkpoints', 'alpha', 'fox', { by: 'lex' });
  console.log('Members: ' + JSON.stringify(members));
}
```

```bash
Members: [{"score":0,"member":"alpha"},{"score":0,"member":"charlie"},{"score":0,"member":"delta"}]
```

---

**Example 3**

```tsx
// Example using zRange() with by 'rank'
async function sortedSetExample3() {
  await redis.zAdd(
    'grades',
    { member: 'sam', score: 80 },
    { member: 'norma', score: 95 },
    { member: 'alex', score: 77 },
    { member: 'don', score: 84 },
    { member: 'zeek', score: 92 }
  );

  // View elements with a rank between 2 and 4 inclusive. Note that ranks start at index 0.
  const members = await redis.zRange('grades', 2, 4, { by: 'rank' });
  console.log('Members: ' + JSON.stringify(members));
}
```

```bash
Members: [{"score":84,"member":"don"},{"score":92,"member":"zeek"},{"score":95,"member":"norma"}]
```

---

**Example 4**

```tsx
// Example using zRank() and zIncrBy()
async function sortedSetExample4() {
  await redis.zAdd(
    'animals',
    { member: 'zebra', score: 92 },
    { member: 'cat', score: 100 },
    { member: 'dog', score: 95 },
    { member: 'elephant', score: 97 }
  );

  // View the rank of 'dog' in the animals set
  // Rank should be '1' since 'dog' has the second lowest score. Note that ranks start at index 0.
  console.log("Dog's rank: " + (await redis.zRank('animals', 'dog')));

  // View the rank of 'zebra'
  console.log("Zebra's rank: " + (await redis.zRank('animals', 'zebra')));

  // Increase the score of 'dog' by 10
  await redis.zIncrBy('animals', 'dog', 10);

  // View the rank of 'dog' again. This time it should be '3' because dog has the highest score.
  console.log(
    "Dog's rank after incrementing score: " + (await redis.zRank('animals', 'dog'))
  );
}
```

```bash
Dog's rank: 1
Zebra's rank: 0
Dog's rank after incrementing score: 3
```

---

**Example 5**

```tsx
// Example using zRemRangeByLex()
async function sortedSetExample5() {
  await redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 0 },
    { member: 'mango', score: 0 },
    { member: 'banana', score: 0 },
    { member: 'orange', score: 0 },
    { member: 'apple', score: 0 }
  );

  // Remove fruits alphabetically ordered between 'kiwi' inclusive and 'orange' exclusive
  // Note: The symbols '[' and '(' indicate inclusive or exclusive, respectively. These must be included in the call to zRemRangeByLex().
  await redis.zRemRangeByLex('fruits', '[kiwi', '(orange');

  // Only 'apple', 'banana', and 'orange' should remain in the set
  const zScanResponse = await redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":0,"member":"apple"},{"score":0,"member":"banana"},{"score":0,"member":"orange"}]}
```

---

**Example 6**

```tsx
// Example using zRemRangeByRank()
async function sortedSetExample6() {
  await redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 10 },
    { member: 'mango', score: 20 },
    { member: 'banana', score: 30 },
    { member: 'orange', score: 40 },
    { member: 'apple', score: 50 }
  );

  // Remove fruits ranked 1 through 3 inclusive
  await redis.zRemRangeByRank('fruits', 1, 3);

  // Only 'kiwi' and 'apple' should remain in the set
  const zScanResponse = await redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":10,"member":"kiwi"},{"score":50,"member":"apple"}]}
```

---

**Example 7**

```tsx
// Example using zRemRangeByScore() example
async function sortedSetExample7() {
  await redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 10 },
    { member: 'mango', score: 20 },
    { member: 'banana', score: 30 },
    { member: 'orange', score: 40 },
    { member: 'apple', score: 50 }
  );

  // Remove fruits scored between 30 and 50 inclusive
  await redis.zRemRangeByScore('fruits', 30, 50);

  // Only 'kiwi' and 'mango' should remain in the set
  const zScanResponse = await redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":10,"member":"kiwi"},{"score":20,"member":"mango"}]}
```

</details>

### Bitfield

| **Command**                                                 | **Action**                                        | **Limits** |
| ----------------------------------------------------------- | ------------------------------------------------- | ---------- |
| [bitfield](https://redis.io/docs/latest/commands/bitfield/) | Performs a sequence of operations on a bit string | Subject to storage quota gating (writes may be blocked if quota exceeded) |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function bitfieldExample() {
  const setBits: number[] = await redis.bitfield('foo', 'set', 'i5', '#0', 11);
  console.log('Set result: ' + setBits); // [0]

  const getBits: number[] = await redis.bitfield('foo', 'get', 'i5', '#0');
  console.log('Get result: ' + setBits); // [11]

  const manyOperations: number[] = await redis.bitfield(
    'bar',
    'set',
    'u2',
    0,
    3,
    'get',
    'u2',
    0,
    'incrBy',
    'u2',
    0,
    1,
    'overflow',
    'sat',
    'get',
    'u2',
    0,
    'set',
    'u2',
    0,
    3,
    'incrBy',
    'u2',
    0,
    1
  );
  console.log('Results of many operations: ' + manyOperations); // [0, 3, 0, 0, 3, 3]
}
```

```bash
fooResults: [1, 0]
barResults: [0, 3, 0, 0, 3, 3]
```

</details>

## Compression (Experimental)

The Redis package includes a `redisCompressed` client that transparently handles compression and decompression of values. This is useful for storing large strings or JSON objects that exceed the Redis storage limits or to optimize storage usage.

To use it, update your import:

```ts
// import { redis } from '@devvit/redis';
import { redisCompressed as redis } from '@devvit/redis';
```

:::warning
**One-Way Migration**: Once you start using `redisCompressed` and writing compressed data, switching back to the standard `redis` client will result in errors when reading that data, as the standard client does not know how to decompress the values.
:::

The `redisCompressed` client automatically:
- Compresses values on write (`set`, `hSet`, `mSet`, `hSetNX`) if it saves space.
- Decompresses values on read (`get`, `hGet`, `mGet`, `hMGet`, `hGetAll`).

**Note:** Existing uncompressed data is **not** automatically compressed when read. It is only compressed when you write it back. To migrate existing large datasets, you need to read and re-write the data.

### Migration Example

Migrating large datasets can take time. To avoid the 30-second execution timeout, we recommend using a scheduled job that processes data in chunks and "daisy chains" itself until completion.

Here is an example of how to implement a migration tool using a Menu Item and the Scheduler.

Register your form handler, menu trigger, and scheduler endpoint here.

```json
{
  "forms": {
    "migrateExampleForm": "/internal/form/ops/migrate-example"
  },
  "menu": {
    "items": [
      {
        "label": "[ops] Migrate Data to Compression",
        "location": "subreddit",
        "forUserType": "moderator",
        "endpoint": "/internal/menu/ops/migrate-example"
      }
    ]
  },
  "scheduler": {
    "tasks": {
      "migrate-example-data": {
        "endpoint": "/internal/scheduler/migrate-example-data"
      }
    }
  }
}
```

Add these route handlers to your Express app.

```ts
import { redis, scheduler } from '@devvit/web/server';
// Import the compressed client
import { redisCompressed } from '@devvit/redis';

const MY_DATA_HASH_KEY = 'my:app:large:dataset';

// 1. Menu Endpoint: Returns the form definition
app.post('/internal/menu/ops/migrate-example', async (_req, res) => {
  res.json({
    showForm: {
      name: 'migrateExampleForm', // Must match key in devvit.json "forms"
      form: {
        title: 'Migrate Hash to Compression',
        acceptLabel: 'Start Migration',
        fields: [
          {
            name: 'startCursor',
            label: 'Start Cursor (0 for beginning)',
            type: 'string',
            defaultValue: '0',
          },
          {
            name: 'chunkSize',
            label: 'Items per batch',
            type: 'number',
            defaultValue: 20000,
          },
        ],
      },
    },
  });
});

// 2. Form Handler: Receives input and schedules the first job
app.post('/internal/form/ops/migrate-example', async (req, res) => {
  const { startCursor, chunkSize } = req.body ?? {};
  const cursor = startCursor || '0';
  const size = Number(chunkSize) || 20000;

  console.log(`[Migration] Manual start requested. Cursor: ${cursor}, Chunk: ${size}`);

  // Kick off the first job in the chain
  await scheduler.runJob({
    name: 'migrate-example-data',
    runAt: new Date(), // Run immediately
    data: {
      cursor,
      chunkSize: size,
      processed: 0,
    },
  });

  res.json({
    showToast: {
      text: 'Migration started in background',
      appearance: 'success',
    },
  });
});

// 3. Scheduler Endpoint: The recursive worker
app.post('/internal/scheduler/migrate-example-data', async (req, res) => {
  const startTime = Date.now();

  try {
    const body = req.body ?? {};
    const data = body.data ?? {};

    let cursor = Number(data.cursor) || 0;
    const chunkSize = Number(data.chunkSize) || 20000;
    const processedTotal = Number(data.processed) || 0;

    console.log(`[Migration] Job started. Cursor: ${cursor}, Target Chunk: ${chunkSize}`);

    let keepRunning = true;
    let processedInJob = 0;
    const SCAN_COUNT = 250; // Internal batch size to keep event loop moving

    while (keepRunning) {
      // Stop if we've processed enough items for this single execution
      if (processedInJob >= chunkSize) {
        break;
      }

      const { cursor: nextCursor, fieldValues } = await redis.hScan(
        MY_DATA_HASH_KEY,
        cursor,
        undefined, // match pattern
        SCAN_COUNT
      );

      // Parallel Processing:
      // We treat the batch as a set of promises to execute simultaneously.
      // Promise.allSettled ensures one failure doesn't crash the whole job.
      await Promise.allSettled(
        fieldValues.map(async ({ field, value }) => {
          // LOGIC:
          // 1. We read the raw value.
          // 2. We write it back using 'redisCompressed'.
          //    The proxy detects the write and compresses the string if beneficial.
          if (value && value.length > 0) {
            await redisCompressed.hSet(MY_DATA_HASH_KEY, { [field]: value });
          }
        })
      );

      processedInJob += fieldValues.length;

      // Cursor logic: 0 means iteration is complete
      if (nextCursor === 0) {
        cursor = 0;
        keepRunning = false;
      } else {
        cursor = nextCursor;
      }

      // Safety: Check execution time.
      // If we are close to 30s (Devvit limit), stop early and requeue.
      if (Date.now() - startTime > 20000) {
        console.log('[Migration] Time limit approaching, stopping early.');
        keepRunning = false;
      }
    }

    const newTotal = processedTotal + processedInJob;

    // Daisy Chaining:
    // If the cursor is not 0, we still have more data to scan.
    // We schedule *this same job* to run again immediately.
    if (cursor !== 0) {
      console.log(`[Migration] Requeueing. Next cursor: ${cursor}. Processed so far: ${newTotal}`);
      await scheduler.runJob({
        name: 'migrate-example-data',
        runAt: new Date(),
        data: {
          cursor,
          chunkSize,
          processed: newTotal,
        },
      });

      res.json({ status: 'requeued', processed: newTotal, cursor });
    } else {
      console.log(`[Migration] COMPLETE. Total items processed: ${newTotal}`);
      res.json({ status: 'success', processed: newTotal });
    }
  } catch (error) {
    console.error('[Migration] Critical Job Error', error);
    res.status(500).json({ status: 'error', message: error.message });
  }
});
```

Note that the job may timeout, in which case you will need to find the last logged cursor to start the menu item action job again. Try adjusting the chunk size if you experience timeouts.

You can monitor the migration progress using the logs command:

```bash
devvit logs r/my-subreddit-to-migrate --since=1h --verbose
```
